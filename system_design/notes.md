# computer architecture

## Disk

Основное хранилище в компьюере. Может сохранять информацию после выключения
компьютера. Обьем современных дисков TB(terabytes 10^2 bytes). Бывает разных
типов Hard disk drives(HDD), Solid-state drive(SSD). HDD механический, может
читать и писать, медленнее чем SSD. SSD стоит немного дороже. Скорость передачи
данных 1 MB порядка 1 миллисекунду 10^-3 sec.

## RAM

Решает задачу хранения информации. Быстрее, дороже чем SSD или HDD. Обьем в
диапазоне от 1-128 GB. Скорость передачи данных 1 MB порядка 1 микросекунды
10^-6 sec. Энергозависимая память, данные теряются после выключения компьютера.

Хранит данные приложений в памяти, включая переменные и выделенную память.

## CACHE

Память для хранения инструкций и данных. Быстрее, чем RAM и SSD. Может хранить
от нескольких килобайт KB 10^3 bytes до десятков MB 10^6 bytes.

## CPU

Для редактирования файла, расположенного на диске (внешняя память), программа
обработки загружает его в ОЗУ (внутренняя память), а конкретные символы, с
которыми в данные доли секунды работает процессор, «поднимаются» по иерархии
выше — в регистры процессора.

Написанный код компилируется в бинарный код, загружается в оперативную память.
Процессор читает и исполняет инструкции, которые включают обработку данных,
находящихся в оперативной памяти или диске. Процессор производит операции
сложения, вычитания, умножения.

Полезные ссылки:
https://xn----7sbbfb7a7aej.xn--p1ai/informatika_10_34_pol/informatika_materialy_zanytii_10_34_pol_13_13.html

# Application high-level architecture

Можно выделить основные компоненты.

## Developer

Разработчик пишет код.

## User

Пользователь использует приложение через интерфейс, например, веб браузер.

## Code Build & CI/CD & Git

Код версионируется, хранится в специальном хранилище, проходит автоматические
проверки, компилируется и поставляется в среду исполнения автоматически.

## Server

Это компьютер, где исполняется скомпилированный код приложения. Сервер может
принимать и отвечать на запросы пользователей. Если пользователей много, то
ресурсов сервера может не хватить, тогда требуется мастабирование сервера.
Вертикальным масштабированием называют увеличение ресурсов сервера, например,
больше оперативной памяти или мощнее процессор. Горизонтальным масштабированием
называют создание копии сервера, возможно, в другой физической локации.

## Storage

Обьем обрабатываемой приложением информации может превышать физические ресурсы
сервера, тогда инфомацию можно хранить в разных физических местах и передавать
по сети. Эффективным образом можно хранить информацию в специальных базах
данных.

## Load balancer

Если пользователей и серверов много, можно распределять нагрузку (запросы
пользователей) между серверами.

## Logging

Позволяет записывать действия приложения и отслеживать что случилось с
приложением в случае неполадки.

## Metrics

Метрики позволяют понять насколько хорошо работает приложение. Сколько запросов
пользователей успешно обработано.

## Alerts

Позволяет оповещать разработчиков в случае, если произошла неполадка. Например,
сервер стал обрабатывать 95 процентов запросов пользователей, метрики
зафиксировали изменений, разработчикам высылается оповещение о неисправности
приложения.

# Design Requirements

Проектирование системы можно свести к трем основным пунктам

1. Moving Data -- Перемещение данных между хранилищами: Базой данных, диском,
   оперативной памятью, процессором. Перемещение данных между разными серверами
   и пользоваталями, возможно, в разных географических локациях.
2. Storing Data -- Хранение данных. Необходимо ответить на вопросы какую задачу
   решаем и как хранить данные эффективно. базы данных? файловая система? Blob
   хранилище? Распределенное хранилище? Ответ зависит от конкретного use case
   приложения.
3. Transforming Data -- Преобразование данных. Например, преобразование лог
   файла о работе приложения в проценты успешных и неудачных запросов
   пользователя.

## Availability

Процент времени, когда приложение работает исправно c понедельника по пятницу с
9 утро до 5 вечера. Иногда требуется 24 часа 7 дней в неделе.

Availability = uptime / (uptime + downtime) %

99% = из 365 дней система не работала 3.65 дней. 99.9 downtime 0.1%

Availability измеряется в терминах 9s.

Хорошим показателем для большой компании является 99.999% 5 min downtime из 365
дней работы.

### Metrics

The measure of availability is used to define SLOs (service level objectives)
and SLAs (service level agreements).

SLA refers to an agreement a company makes with their clients or users to
provide a certain metric of uptime, responsiveness, and responsibilities. SLO
refers to an objective your team must hit to meet the SLA requirements. For
example, AWS's monthly SLA is 99.99% and if not met, they refund a percentage of
service credit.

## Reliability, Fault Tolerance, and Redundancy

Reliability способность приложения выполнять свою фукцию без падений или ошибок
определенное количество времени. Это вероятность, что сервер будет работать
корректно.

Fault Tolerance -- Способность приложения детектировать ошибки,
восстанавливаться к рабочему состоянию, переключаться на другой сервер если
доступен. Как легко сервер упадет или совершит ошибку, если будет DDoS атака.

Fault tolerance in system design is the ability of a system to continue
functioning normally, even in the presence of hardware or software failures.

Redundancy -- резервный потенциал. Приложение имеет резервный сервер, который
при нормальной работе не используется, но если основной сервер упал или ошибся,
то включается резервный сервер и выполняет задачу основного. Fault Tolerance
может быть только при наличии Redundancy.

Redundancy in system design is the duplication of critical components or
resources within a system to ensure the system's continued availability in the
event of a failure. It involves creating multiple copies of the same data,
software, hardware, or network components to provide a backup resource in the
case of an unexpected outage.

## Throughput

Пропускная способность -- количество данных, которое приложение обрабатывает за
период времени. Например, количество обработанных запросов пользователя в
секунду. Количество хранимых даных в год. Количество запросов приложения в базу
данных. Нагрузка на сеть. bytes/second.

Горизонтальное масштабирование увеличивает пропускную способность. Например,
добавили дополнительный сервер.

Вертикальное машстабирование позволяет увеличить пропускную способность на одном
сервере. Например, увеличили оперативную память.

## Latency

Время от начала запроса пользователя до получения ответа пользователем. Включает
в себя время отправки запроса по сети, обработку сервером, обратную отправку
приложением ответа пользователю.

# Networking basics

Клиент посылает запрос или передаёт данные серверу. Сервер принимает запрос,
обрабатывает и отправляет ответ клиенту.

Каждый клиент и сервер имеет IP адрес, который состоит из 32 бит. IPv6 версии IP
128 бит. Бывает публичный и приватный IP. Приватный в локальной сети. Данные
передаются по интернет протоколу. Есть протокол http , это протокол уровня
приложения. Протокол Tcp транспортный. Данные передаются пакетами. Каждый пакет
содержит хидер, от кого IP кому IP, хидер Tcp (номер последовательности в
данных), сами данные.

Роутер имеет публичный IP и позволяет обрабатывать запросы из публичной сети
сервера к локальной сети.

Порты -- канал связи между клиентом и сервером. В http 80 портов, в https 443
порта.

# TCP & UDP

TCP -- протокол транспортного уровня. Гарантирует, что все пакеты будут
доставлены. Устанавливает соединение. Отслеживает количество отправленных и
принятых пакетов. Если пакет потерялся, то пересылает заново. Медленный, но
стабильный.

UDP -- протокол транспортного уровня. Не нужно устаналивать соединение и
отслеживать количество пакетов. Быстрее, по сравнению с TCP. Нет гарантии, что
все пакеты будут приняты. Используется в передаче видеопотока.

# Domain Name System (DNS)

Служба для конвертации понятного пользователю доменного имени напр google.com в
понятный компьютеру IP адрес сервера.

Client -google.com-> ISP(Internet Service Provider) --> ICANN --> Registry -IP->
Client -IP-> Server

# HTTP & RPC

RPC -- Remote procedure call. Например, пользователь заходит на сайт, загружает
фото и нажимает кнопку обработать. Запускается процедура обработки на сервере,
обрабатанная фотография отсылается пользоватлю по HTTP.

HTTP -- Hyper text transport protocol, протокол прикладного уровня. Совершает
запросы request и отправляет ответы responce. Пользователь отсылает request
информацию, сервер обрабатывает и отсылает результат responce. Имеет методы
GET(получить информацию от сервера, html страницу), PUT(обновить что-то),
POST(создать что-либо, аккаунт пользователя), DELETE. Возвращает статус код в
диапазоне 100 - 600 (200 -- успешно, 400 client error, 500 Server error)

HTTPs -- HTTP безопасный, SSL & TLS кодируют всю посылаемую информацию.

# Websockets

Например, хотим сделать онлайн чат. Нужно быстро обмениватсья сообщениями. HTTP
клиент посылает запрос и получает ответ. Это долго.

Вебсокет устанавливает соединение между клиентом и сервером. Клиент и сервер
могут посылать данные напрямую без запросов и ответов. Когда появляется новое
сообщение в чате, клиент получает информацию напрямую от сервера.

# Application programming interface (API)

это код, который позволяет двум приложениям обмениваться данными с сервера.

## Representation State Transfer REST

Построен поверх HTTP. Сервер не должен хранить информацию о состоянии
(проведенных операций) клиента. Каждый запрос от клиента должен содержать только
ту информацию, которая нужна для получения данных от сервера. Подходит для
горизонтального масштабирования. Формат данных JSON.

Пример REST API https://youtube.com/videos?offset=0,limit=10

URL:https://youtube.com/ OBJECT: videos PARAMETERS: offset=0,limit=10

## GraphQL

Относительно новый. Построен на HTTP. Использует только POST. Работа с данными
идет с помощью двух категорий запросов:на чтение (read) данных — в самом языке
их называют «запросы» (querys);на изменение (создание, обновление, удаление)
данных (для них применяют термин mutations).

В отличие от архитектуры REST, не требует наличия нескольких эндпойнтов для
каждого источника информации — все данные передаются через один шлюз уже
отфильтрованными схемой. То есть клиент (пользователь) получает именно ту
информацию, которую он запрашивал. В REST API для выполнения этой задачи
потребовалось бы создание или нового эндпойнта под каждый запрос, или одной
общей конечной точки с последующей фильтрацией данных уже на стороне самого
клиента доступными ему средствами.

https://blog.skillfactory.ru/glossary/graphql/

## gRPC

Построен на HTTP/2. Нативно не поддерживается браузером. Для использования нужен
прокси. Используется для server2server коммуникации. Быстрее, чем REST.
Используется для стриминга данных.

https://www.youtube.com/watch?v=bfdF4AJELDc

## API Design

Проектирование API можно сравнить с проектирование функций, сущностей. Важно
сформулировать контракт вход, выход приложения. Как пользователь будет
взаимодействовать с приложением. Если версия API меняется, то необходимо
поддерживать старую и новую версию.

Например, API Twitter

функция: создать твит. название функции createTweet(userId, content) вход:
создвать твит. REST запрос POST типа https://api.twitter.com/v1.0/tweet - POST.
В теле запроса есть параметры userId, content. Запрос представлен json. выход:
Tweet REST ответ обьект Tweet с полями userId, tweetId, content, createdAt,
likes

Для запроса конкретного твита можно создать API
https://api.twitter.com/v1.0/tweet/:Id - GET

Если хотим посмотреть несколько твитов
https://api.twitter.com/v1.0/users/:Id/tweets?limit=10&offset=0 - GET limit
сколько твитов запросить у юзера Id начиная с offset

# Caching

Важный концепт в дизайне. Кэш позволяет хранить наиболее используемую
информацию. Увеличивает пропускную способность за счет быстрого доступа к
используемой приложением информации.

Например, откроем браузер и зайдем на любой сайт. Браузер проверит нет ли в кэше
данных по этому запросу, если не обнаружит данных, то пошлет информацию на
сервер с целью загрузить данные с сервера и сохранить данные в кэш. Запрос к
серверу и скачивание данных может быть длительным процессом. В дальнейшем, при
запросе данных, будут загружаться данные из кэша, это быстрее.

Существуют разные уровни кэша:

1. Регистры процессора
2. Кэш процессора L1 L2 L3 (Быстрая память, мало обьема)
3. Оперативная память (Энергозависимая память, может работать с процессором.)
4. Диск (Энергонезависимая память, но слишком медленно для работы с процессором)
5. Удаленное хранилище( Надежно, но чтобы пользоваться нужно скачать по сети
   данные на компьютер с приложением.)

Напримео, когда клиент посылает запрос createTweet серверу. Сервер принимает
запрос, передает приложению, приложение исполняется процессором, процессор ищет
данные в памяти с высокого уровня, если не находит, то обращается к памяти
низкого уровня. Это занимает время. В следущий раз, запрос обрабаотается быстрее
за счет обращения к памяти высокого уровня.

write-back стратегия кэширование -- периодически записывать данные из
энергозависимой памяти в энергонезависимую для предотвращения потери информации
при падении сервиса.

Eviction cache -- вытеснение старых данных из кэша в пользу новых данных.
Существуют политики Least Recently Used(LRU) и Least Frequently Used(LFU).

# Content Delivery Network (CDN)

Имеется один сервер и множество клиентов по всему миру. Клиенту ближе к серверу
географически понадобится больше времени на загрузку контента. Клиенту дальше от
сервера понадобится больше времени за получение контента. Решением является CDN
-- статический сервер с контентом, расположенный в разных частях мира, чтобы
обеспечить равномерную раздачу информации. Клиенты в разных частях мира получают
информацию за одинаковое время.

Увеличивает latency и увеличивает availability.

Существуют Push / Pull CDN.

Логика работы CDN похожа на кэширование:

1. Клиент запрашивает данные у ближайшего CDN сервера
2. Если данные есть, то отправляются клиенту, иначе запрашиваются у главного
   сервера.
